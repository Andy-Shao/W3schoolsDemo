<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Complex Types</title>
<link rel="stylesheet" href="../../resources/css/note.css"/>
</head>
<body>
<h1>XSD Complex Elements</h1>
<p>A complex element contains other elements and/or attributes.</p>
<h2>What is a Complex Element?</h2>
<p>A complex element is an XML element that contains other elements and/or attributes.</p>
<p>There are four kinds of complex elements:</p>
<ul>
<li>empty elements</li>
<li>elements that contain only other elements</li>
<li>elements that contain only text</li>
<li>elements that contain both other elements and text</li>
</ul>
<p><b>Note</b>: Each of these elements may contain attributes as well!</p>
<h2>Examples of Complex Elements</h2>
<p>A complex XML element, "product", which is empty:</p>
<code><pre>
&lt;product pid="1345"/&gt;
</pre></code>
<p>A complex XML element, "employee", which contains only other elements:</p>
<code><pre>
&lt;employee&gt;
    &lt;firstname&gt;John&lt;/firstname&gt;
    &lt;lastname&gt;Smith&lt;/lastname&gt;
&lt;/empoyee&gt;
</pre></code>
<p>A complex XML element, "food", which contains only text:</p>
<code><pre>
&lt;food type="dessert"&gt;Ice cream&lt;/food&gt;
</pre></code>
<p>A complex XML element, "description", which contains both elements and text:</p>
<code><pre>
&lt;description&gt;
    It happened on &lt;date lang="norwegian"&gt;03.03.99&lt;/date&gt; ....
&lt;/description&gt;
</pre></code>
<h2>How to Define a Complex Element</h2>
<p>Look at this complex XML element, "employee", which contains only other elements:</p>
<p>We can define a complex element in an XML Schema two different ways:</p>
<p>1. The "employee" element can be declared directly by naming the element, like this:</p>
<code><pre>
&lt;xs:element name="employee"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element name="firstname" type="xs:string"/&gt;
            &lt;xs:element name="lastname" type="xs:string"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></code>
<p>If you use the method described above, only the "employee" element can use the specified 
complex type. Note that the child elements, "firstname" and "lastname", are surrounded by 
the &lt;sequence&gt; indicator. This means that the child elements must appear in the same order 
as they are declared. You will learn more about indicators in the XSD Indicators chapter.</p>
<p>2. The "employee" element can have a type attribute that refers to the name of the complex 
type to use:</p>
<code><pre>
&lt;xs:element name="employee" type="personinfor"/&gt;

&lt;xs:complexType name="personinfo"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="firstname" type="xs:string"/&gt;
        &lt;xs:element name="lastname" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;
</pre></code>
<p>If you use the method described above, several elements can refer to the same complex type,
like this:</p>
<code><pre>
&lt;xs:element name="employee" type="personinfo"/&gt;
&lt;xs:element name="student" type="personinfo"/&gt;
&lt;xs:element name="member" type="personinfo"/&gt;

&lt;xs:complexType name="personinfo"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="firstname" type="xs:string"/&gt;
        &lt;xs:element name="lastname" type="xs:string/&gt;
    &lt;/xs:sequenc&gt;
&lt;/xs:complexType&gt;
</pre></code>
<p>You can also base a complex element on an existing complex element and add some elements,
like this:</p>
<code><pre>
&lt;xs:element name="employee" type="fullpersoninfo"/&gt;

&lt;xs:complexType name="personinfo"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="firstname" type="xs:string"/&gt;
        &lt;xs:element name="lastname" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

&lt;xs:complexType name="fullpersoninfo"&gt;
    &lt;xs:complexContent&gt;
        &lt;xs:extension base="personinfo"&gt;
            &lt;xs:sequence&gt;
                &lt;xs:element name="address" type="xs:string"/&gt;
                &lt;xs:element name="city" type="xs:string"/&gt;
                &lt;xs:element name="country" type="xs:string"/&gt;
            &lt;/xs:sequence&gt;
        &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
&lt;/xs:complexType&gt;
</pre></code>
<hr/>


<h1>XSD Empty Elements</h1>
<p>An empty complex element cannot have contents, only attributes.</p>
<h2>Complex Empty Elemetns</h2>
<p>An empty XML element:</p>
<code><pre>
&lt;product prodid="12345"/&gt;
</pre></code>
<p>The "product" element above has no content at all. To define a type with no content, 
we must define a type that allows elements in its content, but we do not actually declare 
any elements, like this:</p>
<code><pre>
&lt;xs:element name="produce"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:complexContent&gt;
            &lt;xs:restriction base="xs:integer"&gt;
                &lt;xs:attribute name="prodid" type="xs:positiveInteger"/&gt;
            &lt;/xs:restriction&gt;
        &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></code>
<p>In the example above, we define a complex type with a complex content. The complexContent 
element signals that we intend to restrict or extend the content model of a complex type, 
and the restriction of integer declares one attribute but does not introduce any element content.</p>
<p>However, it is possible to declare the "product" element more compactly, like this:</p>
<code><pre>
&lt;xs:element name="product"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:attribute name="prodid" type="xs:positiveInteger"/&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></code>
<p>Or you can give the complexType element a name, and let the "product" element have a type 
attribute that refers to the name of the complexType (if you use this method, several elements 
can refer to the same complex type):</p>
<code><pre>
&lt;xs:element name="product" type="prodtype"/&gt;

&lt;xs:complexType name="prodtype"&gt;
    &lt;xs:attribute name="prodid" type="xs:positiveInteger"/&gt;
&lt;/xs:complexType&gt;
</pre></code>
<hr/>

<h1>XSD Elements Only</h1>
<p>An "elements-only" complex type contains an element that contains only other elements.</p>
<h2>Complex Types Containing Elements Only</h2>
<p>An XML element, "person", that contains only other elements:</p>
<code><pre>
&lt;person&gt;
    &lt;firstname&gt;John&lt;/fristname&gt;
    &lt;lastname&gt;Smith&lt;/lastname&gt;
&lt;/person&gt;
</pre></code>
<p>You can define the "person" element in a schema, like this:</p>
<code><pre>
&lt;xs:element name="person"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:element name="firstname" type="xs:string:"/&gt;
        &lt;xs:element name="lastname" type="xs:string:"/&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></code>
<p>Notice the &lt;xs:sequence&gt; tag. It means that the elements defined ("firstname" and 
"lastname") must appear in that order inside a "person" element.</p>
<p>Or you can give the complexType element a name, and let the "person" element have a type 
attribute that refers to the name of the complexType (if you use this method, several 
elements can refer to the same complex type):</p>
</pre></code>
<p>You can define the "person" element in a schema, like this:</p>
<code><pre>
&lt;element name="person" type="persontype"/&gt;

&lt;xs:complexType name="persontype"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="firstname" type="xs:string"/&gt;
        &lt;xs:element name="firstname" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;
</pre></code>
<hr/>

<h1>XSD Text-Only Elements</h1>
<p>A complex text-only element can contain text and attributes.</p>
<h2>Complex Text-Only Elements</h2>
<p>This type contains only simple content (text and attributes), therefore we add a 
simpleContent element around the content. When using simple content, you must define 
an extension OR a restriction within the simpleContent element, like this:</p>
<code><pre>
&lt;xs:element name="somename"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:simpleContent&gt;
            &lt;xs:extension base="basetype"&gt;
                ....
                ....
            &lt;/xs:extension&gt;
        &lt;/xssimpleContent&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

OR

&lt;xs:element name="somename"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:simpleContent&gt;
            &lt;xs:restriction base="basetype"&gt;
                ....
                ....
            &lt;/xs:restriction&gt;
        &lt;/xssimpleContent&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></code>
<p><b>Tip</b>: Uset the extension/restriction element to expand or limit the base simple 
type for the element.</p>
<p>Here is an example of an XML element, "shoesize", that contains text-only:</p>
<code><pre>
&lt;xs:element name="shoesize&gt;
    &lt;xs:complexType&gt;
        &lt;xs:simpleContent&gt;
            &lt;xs:restriction base="xs:integer"&gt;
                &lt;xs:attribute name="country" type="xs:string" /&gt;
            &lt;/xs:restriction&gt;
        &lt;/xssimpleContent&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></code>
<p>We could also give the complexType element a name, and let the "shoesize" element 
have a type attribute that refers to the name of the complexType (if you use this 
method, several elements can refer to the same complex type):</p>
<code><pre>
&lt;xs:element name="shoesize" type="shoetype"/&gt;

&lt;xs:complexType name="shoetype"&gt;
    &lt;xs:simpleContent&gt;
        &lt;xs:extension base="xs:integer"&gt;
            &lt;xs:attribute name="country" type="xs:string" /&gt;
        &lt;/xs:extension&gt;
    &lt;/xs:simpleContent&gt;
&lt;/xs:complexType&gt;
</pre></code>
<hr/>

<h1>XSD Mixed Content</h1>
<p>A mixed complex type element can contain attributes, elements, and text.</p>
<h2>Complex Types with Mixed Content</h2>
<p>An XML element, "letter", that contains both text and other elements:</p>
<code><pre>
&lt;letter&gt;
    Dear Mr.&lt;name&gt;JohnSmith&lt;/&gt;.
    Your order &lt;orderid&gt;1032&lt;/&gt;
    will be shipped on &lt;shipdate&gt;2001-07-13&lt;/shipdate&gt;.
&lt;/letter&gt;
</pre></code>
<p>The following schema declares the "letter" element:</p>
<code><pre>
&lt;xs:element name="letter"&gt;
    &lt;xs:complexType mixed="true"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element name="name" type="xs:string"/&gt;
            &lt;xs:element name="orderid" type="xs:positiveInteger"/&gt;
            &lt;xs:element name="shipdate" type="xs:date"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></code>
<p><b>Note</b>: To enable character data to appear between the child-elements of "letter", 
the mixed attribute must be set to "true". The &lt;xs:sequence&gt; tag means that the 
elements defined (name, orderid and shipdate) must appear in that order inside a "letter" element.</p>
<p>We could also give the complexType element a name, and let the "letter" element have a 
type attribute that refers to the name of the complexType (if you use this method, several 
elements can refer to the same complex type):</p>
<code><pre>
&lt;xs:element name="letter" type="lettertype"/&gt;

&lt;xs:complexType name="lettertype" mixed="true"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="name" type="xs:string"/&gt;
        &lt;xs:element name="orderid" type="xs:positiveInteger"/&gt;
        &lt;xs:element name="shipdate" type="xs:date"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;
</pre></code>
</body>
</html>
