<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Complex Types</title>
<link rel="stylesheet" href="../../resources/css/note.css"/>
</head>
<body>
<h1>XSD Complex Elements</h1>
<p>A complex element contains other elements and/or attributes.</p>
<h2>What is a Complex Element?</h2>
<p>A complex element is an XML element that contains other elements and/or attributes.</p>
<p>There are four kinds of complex elements:</p>
<ul>
<li>empty elements</li>
<li>elements that contain only other elements</li>
<li>elements that contain only text</li>
<li>elements that contain both other elements and text</li>
</ul>
<p><b>Note</b>: Each of these elements may contain attributes as well!</p>
<h2>Examples of Complex Elements</h2>
<p>A complex XML element, "product", which is empty:</p>
<code><pre>
&lt;product pid="1345"/&gt;
</pre></code>
<p>A complex XML element, "employee", which contains only other elements:</p>
<code><pre>
&lt;employee&gt;
    &lt;firstname&gt;John&lt;/firstname&gt;
    &lt;lastname&gt;Smith&lt;/lastname&gt;
&lt;/empoyee&gt;
</pre></code>
<p>A complex XML element, "food", which contains only text:</p>
<code><pre>
&lt;food type="dessert"&gt;Ice cream&lt;/food&gt;
</pre></code>
<p>A complex XML element, "description", which contains both elements and text:</p>
<code><pre>
&lt;description&gt;
    It happened on &lt;date lang="norwegian"&gt;03.03.99&lt;/date&gt; ....
&lt;/description&gt;
</pre></code>
<h2>How to Define a Complex Element</h2>
<p>Look at this complex XML element, "employee", which contains only other elements:</p>
<p>We can define a complex element in an XML Schema two different ways:</p>
<p>1. The "employee" element can be declared directly by naming the element, like this:</p>
<code><pre>
&lt;xs:element name="employee"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element name="firstname" type="xs:string"/&gt;
            &lt;xs:element name="lastname" type="xs:string"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></code>
<p>If you use the method described above, only the "employee" element can use the specified 
complex type. Note that the child elements, "firstname" and "lastname", are surrounded by 
the &lt;sequence&gt; indicator. This means that the child elements must appear in the same order 
as they are declared. You will learn more about indicators in the XSD Indicators chapter.</p>
<p>2. The "employee" element can have a type attribute that refers to the name of the complex 
type to use:</p>
<code><pre>
&lt;xs:element name="employee" type="personinfor"/&gt;

&lt;xs:complexType name="personinfo"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="firstname" type="xs:string"/&gt;
        &lt;xs:element name="lastname" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;
</pre></code>
<p>If you use the method described above, several elements can refer to the same complex type,
like this:</p>
<code><pre>
&lt;xs:element name="employee" type="personinfo"/&gt;
&lt;xs:element name="student" type="personinfo"/&gt;
&lt;xs:element name="member" type="personinfo"/&gt;

&lt;xs:complexType name="personinfo"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="firstname" type="xs:string"/&gt;
        &lt;xs:element name="lastname" type="xs:string/&gt;
    &lt;/xs:sequenc&gt;
&lt;/xs:complexType&gt;
</pre></code>
<p>You can also base a complex element on an existing complex element and add some elements,
like this:</p>
<code><pre>
&lt;xs:element name="employee" type="fullpersoninfo"/&gt;

&lt;xs:complexType name="personinfo"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="firstname" type="xs:string"/&gt;
        &lt;xs:element name="lastname" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

&lt;xs:complexType name="fullpersoninfo"&gt;
    &lt;xs:complexContent&gt;
        &lt;xs:extension base="personinfo"&gt;
            &lt;xs:sequence&gt;
                &lt;xs:element name="address" type="xs:string"/&gt;
                &lt;xs:element name="city" type="xs:string"/&gt;
                &lt;xs:element name="country" type="xs:string"/&gt;
            &lt;/xs:sequence&gt;
        &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
&lt;/xs:complexType&gt;
</pre></code>
<hr/>


<h1>XSD Empty Elements</h1>
<p>An empty complex element cannot have contents, only attributes.</p>
<h2>Complex Empty Elemetns</h2>
<p>An empty XML element:</p>
<code><pre>
&lt;product prodid="12345"/&gt;
</pre></code>
<p>The "product" element above has no content at all. To define a type with no content, 
we must define a type that allows elements in its content, but we do not actually declare 
any elements, like this:</p>
<code><pre>
&lt;xs:element name="produce"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:complexContent&gt;
            &lt;xs:restriction base="xs:integer"&gt;
                &lt;xs:attribute name="prodid" type="xs:positiveInteger"/&gt;
            &lt;/xs:restriction&gt;
        &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></code>
<p>In the example above, we define a complex type with a complex content. The complexContent 
element signals that we intend to restrict or extend the content model of a complex type, 
and the restriction of integer declares one attribute but does not introduce any element content.</p>
<p>However, it is possible to declare the "product" element more compactly, like this:</p>
<code><pre>
&lt;xs:element name="product"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:attribute name="prodid" type="xs:positiveInteger"/&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></code>
<p>Or you can give the complexType element a name, and let the "product" element have a type 
attribute that refers to the name of the complexType (if you use this method, several elements 
can refer to the same complex type):</p>
<code><pre>
&lt;xs:element name="product" type="prodtype"/&gt;

&lt;xs:complexType name="prodtype"&gt;
    &lt;xs:attribute name="prodid" type="xs:positiveInteger"/&gt;
&lt;/xs:complexType&gt;
</pre></code>
<hr/>

<h1>XSD Elements Only</h1>
<p>An "elements-only" complex type contains an element that contains only other elements.</p>
<h2>Complex Types Containing Elements Only</h2>
<p>An XML element, "person", that contains only other elements:</p>
<code><pre>
&lt;person&gt;
    &lt;firstname&gt;John&lt;/fristname&gt;
    &lt;lastname&gt;Smith&lt;/lastname&gt;
&lt;/person&gt;
</pre></code>
<p>You can define the "person" element in a schema, like this:</p>
<code><pre>
&lt;xs:element name="person"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:element name="firstname" type="xs:string:"/&gt;
        &lt;xs:element name="lastname" type="xs:string:"/&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></code>
<p>Notice the &lt;xs:sequence&gt; tag. It means that the elements defined ("firstname" and 
"lastname") must appear in that order inside a "person" element.</p>
<p>Or you can give the complexType element a name, and let the "person" element have a type 
attribute that refers to the name of the complexType (if you use this method, several 
elements can refer to the same complex type):</p>
</pre></code>
<p>You can define the "person" element in a schema, like this:</p>
<code><pre>
&lt;element name="person" type="persontype"/&gt;

&lt;xs:complexType name="persontype"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="firstname" type="xs:string"/&gt;
        &lt;xs:element name="firstname" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;
</pre></code>
<hr/>

<h1>XSD Text-Only Elements</h1>
<p>A complex text-only element can contain text and attributes.</p>
<h2>Complex Text-Only Elements</h2>
<p>This type contains only simple content (text and attributes), therefore we add a 
simpleContent element around the content. When using simple content, you must define 
an extension OR a restriction within the simpleContent element, like this:</p>
<code><pre>
&lt;xs:element name="somename"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:simpleContent&gt;
            &lt;xs:extension base="basetype"&gt;
                ....
                ....
            &lt;/xs:extension&gt;
        &lt;/xssimpleContent&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

OR

&lt;xs:element name="somename"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:simpleContent&gt;
            &lt;xs:restriction base="basetype"&gt;
                ....
                ....
            &lt;/xs:restriction&gt;
        &lt;/xssimpleContent&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></code>
<p><b>Tip</b>: Uset the extension/restriction element to expand or limit the base simple 
type for the element.</p>
<p>Here is an example of an XML element, "shoesize", that contains text-only:</p>
<code><pre>
&lt;xs:element name="shoesize&gt;
    &lt;xs:complexType&gt;
        &lt;xs:simpleContent&gt;
            &lt;xs:restriction base="xs:integer"&gt;
                &lt;xs:attribute name="country" type="xs:string" /&gt;
            &lt;/xs:restriction&gt;
        &lt;/xssimpleContent&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></code>
<p>We could also give the complexType element a name, and let the "shoesize" element 
have a type attribute that refers to the name of the complexType (if you use this 
method, several elements can refer to the same complex type):</p>
<code><pre>
&lt;xs:element name="shoesize" type="shoetype"/&gt;

&lt;xs:complexType name="shoetype"&gt;
    &lt;xs:simpleContent&gt;
        &lt;xs:extension base="xs:integer"&gt;
            &lt;xs:attribute name="country" type="xs:string" /&gt;
        &lt;/xs:extension&gt;
    &lt;/xs:simpleContent&gt;
&lt;/xs:complexType&gt;
</pre></code>
<hr/>

<h1>XSD Mixed Content</h1>
<p>A mixed complex type element can contain attributes, elements, and text.</p>
<h2>Complex Types with Mixed Content</h2>
<p>An XML element, "letter", that contains both text and other elements:</p>
<code><pre>
&lt;letter&gt;
    Dear Mr.&lt;name&gt;JohnSmith&lt;/&gt;.
    Your order &lt;orderid&gt;1032&lt;/&gt;
    will be shipped on &lt;shipdate&gt;2001-07-13&lt;/shipdate&gt;.
&lt;/letter&gt;
</pre></code>
<p>The following schema declares the "letter" element:</p>
<code><pre>
&lt;xs:element name="letter"&gt;
    &lt;xs:complexType mixed="true"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element name="name" type="xs:string"/&gt;
            &lt;xs:element name="orderid" type="xs:positiveInteger"/&gt;
            &lt;xs:element name="shipdate" type="xs:date"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></code>
<p><b>Note</b>: To enable character data to appear between the child-elements of "letter", 
the mixed attribute must be set to "true". The &lt;xs:sequence&gt; tag means that the 
elements defined (name, orderid and shipdate) must appear in that order inside a "letter" element.</p>
<p>We could also give the complexType element a name, and let the "letter" element have a 
type attribute that refers to the name of the complexType (if you use this method, several 
elements can refer to the same complex type):</p>
<code><pre>
&lt;xs:element name="letter" type="lettertype"/&gt;

&lt;xs:complexType name="lettertype" mixed="true"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="name" type="xs:string"/&gt;
        &lt;xs:element name="orderid" type="xs:positiveInteger"/&gt;
        &lt;xs:element name="shipdate" type="xs:date"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;
</pre></code>
<hr/>

<h1>XSD Indicators</h1>
<p>We can control How elements are to be used in documents with indicators.</p>
<h2>Indicators</h2>
<p>There are seven indicators:</p>
<p>Order indicators:</p>
<ul>
<li>All</li>
<li>Choice</li>
<li>Sequence</li>
</ul>
<p>Occurrence indicators:</p>
<ul>
<li>maxOccurs</li>
<li>minOccurs</li>
</ul>
<p>Group indicators:</p>
<ul>
<li>Group name</li>
<li>attributeGroup name</li>
</ul>
<h2>Order Indicators</h2>
<p>Order indicators are used to define the order of the elements.</p>
<h3>ALl Indicator</h3>
<p>The &lt;all&gt; indicator specifies that the child elements can appear in any order, and 
that each child element must occur only once:</p>
<code><pre>
&lt;xs:element name="person"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:all&gt;
            &lt;xs:element name="firstname" type="xs:string"/&gt;
            &lt;xs:element name="lastname" type="xs:string"/&gt;
        &lt;/xs:all&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></code>
<p><b>Note</b>: When using the&lt;all&gt; indicator you can set the &lt;minOccurs&gt; indicator 
to 0 or 1 and the &lt;maxOccurs&gt; indicator can only be set to 1 (the &lt;minOccurs&gt; and 
&lt;maxOccurs&gt; are described later).</p>
<h2>Choice Indicator</h2>
<p>The &lt;choice&gt; indicator specifies that either one child element or another can occur:</p>
<code><pre>
&lt;xs:element name="person"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:choice&gt;
            &lt;element name="employee" type="employee"/&gt;
            &lt;element name="member" type="member"/&gt;
        &lt;/xs:choice&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></code>
<h2>Sequence Indicator</h2>
<p>The &lt;sequence&gt; indicator specifies that the child elements must appear in a 
specific order:</p>
<code><pre>
&lt;xs:element name="person"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:choice&gt;
            &lt;element name="employee" type="employee"/&gt;
            &lt;element name="member" type="member"/&gt;
        &lt;/xs:choice&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></code>
<h2>Occurrence Indicators</h2>
<p>Occurrence indicators are used to define how often an element can occur.</p>
<p><b>Note</b>: For all "Order" and "Group" indicators (any, all, choice, sequence, group name, 
and group reference) the default value for maxOccurs and minOccurs is 1.</p>
<h3>maxOccurs Indicator</h3>
<p>The &lt;maxOccurs&gt; indicator specifies the maximum number of times an element can occur:</p>
<code><pre>
&lt;xs:element name="person"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:choice&gt;
            &lt;element name="full_name" type="xs:string"/&gt;
            &lt;element name="child_name" type="xs:string" maxOccurs="10"/&gt;
        &lt;/xs:choice&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></code>
<p>The example above indicates that the "child_name" element can occur a minimum of one 
time (the default value for minOccurs is 1) and a maximum of ten times in the "person" element.</p>
<h3>minOccurs Indicator</h3>
<p>The &lt;minOccurs&gt; indicator specifies the minimum number of times an element can occur:</p>
<code><pre>
&lt;xs:element name="person"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element name="full_name" type="xs:string"/&gt;
            &lt;xs:element name="child_name" type="xs:string" maxOccurs="10" minOccurs="0"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></code>
<p>The example above indicates that the "child_name" element can occur a minimum of zero 
times and a maximum of ten times in the "person" element.</p>
<p><b>Tip</b>: To allow an element to appear an unlimited number of times, use the 
maxOccurs="unbounded" statement:</p>
<p><b>A working example:</b></p>
<p>An XML file called "Myfamily.xml":</p>
<a href="Myfamily.xml">Example</a>
<p>The XML file above contains a root element named "persons". Inside this root element we have 
defined three "person" elements. Each "person" element must contain a "full_name" element and 
it can contain up to five "child_name" elements.</p>
<hr/>

<h2>Group Indicators</h2>
<p>Group indicators are used to define related sets of elements.</p>
<h3>Element Groups</h3>
<p>Element groups are defined with the group declaration, like this:</p>
<code><pre>
&lt;xs:group name="groupname"&gt;
...
&lt;/xs:group&gt;
</pre></code>
<p>You must define an all, choice, or sequence element inside the group declaration.  The 
following example defines a group named "persongroup", that defines a group of elements 
that must occur in an exact sequence:</p>
<code><pre>
&lt;xs:group name="persongroup"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="firstname" type="xs:string"/&gt;
        &lt;xs:element name="lastname" type="xs:string"/&gt;
        &lt;xs:element name="birthday" type="xs:date"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:group&gt;
</pre></code>
<p>After you have defined a group, you can reference it in another definition, like this:</p>
<code><pre>
&lt;xs:group name="persongroup"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="firstname" type="xs:string"/&gt;
        &lt;xs:element name="lastname" type="xs:string"/&gt;
        &lt;xs:element name="birthday" type="xs:date"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:group&gt;

&lt;xs:element name="person" type="personinfo"/&gt;

&lt;xs:complexType name="personinfo"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:group ref="persongroup"/&gt;
        &lt;xs:element name="country" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;
</pre></code>
<h3>Attribute Groups</h3>
<p>Attribute groups are defined with the attributeGroup declaration, like this:</p>
<code><pre>
&lt;xs:attributeGroup name="groupname"&gt;
...
&lt;/xs:attributeGroup&gt;
</pre></code>
<p>The following example defines an attribute group named "personattrgroup":</p>
<code><pre>
&lt;xs:attributeGroup name="personattrgroup"&gt;
    &lt;xs:attribute name="firstname" type="xs:string"/&gt;
    &lt;xs:attribute name="lastname" type="xs:string"/&gt;
    &lt;xs:attribute name="birthday" type="xs:date"/&gt;
&lt;/xs:attributeGroup&gt;
</pre></code>
<p>After you have defined an attribute group, you can reference it in another 
definition, like this:</p>
<code><pre>
&lt;xs:attributeGroup name="personattrgroup"&gt;
    &lt;xs:attribute name="firstname" type="xs:string"/&gt;
    &lt;xs:attribute name="lastname" type="xs:string"/&gt;
    &lt;xs:attribute name="birthday" type="xs:date"/&gt;
&lt;/xs:attributeGroup&gt;

&lt;xs:element name="person"&gt;
    &lt;xs:complexType&gt;
        &lt;attributeGroup ref="personattrgroup"/&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></code>
<hr/>

<h1>XSD The &lt;any&gt; Element</h1>
<p>The &lt;any&gt; element enables us to extend the XML document with elements not specified 
by the schema!</p>
<h2>The &lt;andy&gt; Element</h2>
<p>The &lt;any&gt; element enables us to extend the XML document with elements not specified 
by the schema.</p>
<p>The following example is a fragment from an XML schema called "family.xsd". It shows a 
declaration for the "person" element. By using the &lt;any&gt; element we can extend 
(after &lt;lastname&gt;) the content of "person" with any element:</p>
<code><pre>
&lt;xs:element name="person"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element name="firstname" type="xs:string"/&gt;
            &lt;xs:element name="lastname" type="xs:string"/&gt;
            &lt;xs:any minOccurs="0"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></code>
<p>Now we want to extend the "person" element with a "children" element. In this case we can 
do so, even if the author of the schema above never declared any "children" element.</p>
<a href="Any_example.xsd">Example</a>
<p>The XML file above is valid because the schema "family.xsd" allows us to extend the "person" 
element with an optional element after the "lastname" element.</p>
<p>The &lt;any&gt; and &lt;anyAttribute&gt; elements are used to make EXTENSIBLE documents! They 
allow documents to contain additional elements that are not declared in the main XML schema.</p>
<hr/>

<h1>XSD The &lt;anyAttribute&gt; Element</h1>
<p>The &lt;anyAttribute&gt; element enables us to extend the XML document with attributes not 
specified by the schema!</p>
<h2>The &lt;andyAttribute&gt; Element</h2>
<p>The &lt;anyAttribute&gt; element enables us to extend the XML document with attributes not 
specified by the schema.</p>
<p>The following example is a fragment from an XML schema called "family.xsd". It shows a 
declaration for the "person" element. By using the &lt;anyAttribute&gt; element we can add any 
number of attributes to the "person" element:</p>
<code><pre>
&lt;xs:element name="person"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element name="firstname" type="xs:string"/&gt;
            &lt;xs:element name="lastname" type="xs:string"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:anyAttribute/&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></code>
<p>Now we want to extend the "person" element with a "gender" attribute. In this case we can 
do so, even if the author of the schema above never declared any "gender" attribute</p>
<a href="any_attribute.xml">Example</a>
<p>The XML file above is valid because the schema "family.xsd" allows us to add an attribute 
to the "person" element.</p>
<p>The &lt;any&gt; and &lt;anyAttribute&gt; elements are used to make EXTENSIBLE documents! 
They allow documents to contain additional elements that are not declared in the main XML schema.</p>
</body>
</html>
