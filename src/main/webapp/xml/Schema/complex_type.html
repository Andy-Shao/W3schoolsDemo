<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Complex Types</title>
<link rel="stylesheet" href="../../resources/css/note.css"/>
</head>
<body>
<h1>XSD Complex Elements</h1>
<p>A complex element contains other elements and/or attributes.</p>
<h2>What is a Complex Element?</h2>
<p>A complex element is an XML element that contains other elements and/or attributes.</p>
<p>There are four kinds of complex elements:</p>
<ul>
<li>empty elements</li>
<li>elements that contain only other elements</li>
<li>elements that contain only text</li>
<li>elements that contain both other elements and text</li>
</ul>
<p><b>Note</b>: Each of these elements may contain attributes as well!</p>
<h2>Examples of Complex Elements</h2>
<p>A complex XML element, "product", which is empty:</p>
<code><pre>
&lt;product pid="1345"/&gt;
</pre></code>
<p>A complex XML element, "employee", which contains only other elements:</p>
<code><pre>
&lt;employee&gt;
    &lt;firstname&gt;John&lt;/firstname&gt;
    &lt;lastname&gt;Smith&lt;/lastname&gt;
&lt;/empoyee&gt;
</pre></code>
<p>A complex XML element, "food", which contains only text:</p>
<code><pre>
&lt;food type="dessert"&gt;Ice cream&lt;/food&gt;
</pre></code>
<p>A complex XML element, "description", which contains both elements and text:</p>
<code><pre>
&lt;description&gt;
    It happened on &lt;date lang="norwegian"&gt;03.03.99&lt;/date&gt; ....
&lt;/description&gt;
</pre></code>
<h2>How to Define a Complex Element</h2>
<p>Look at this complex XML element, "employee", which contains only other elements:</p>
<p>We can define a complex element in an XML Schema two different ways:</p>
<p>1. The "employee" element can be declared directly by naming the element, like this:</p>
<code><pre>
&lt;xs:element name="employee"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element name="firstname" type="xs:string"/&gt;
            &lt;xs:element name="lastname" type="xs:string"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></code>
<p>If you use the method described above, only the "employee" element can use the specified 
complex type. Note that the child elements, "firstname" and "lastname", are surrounded by 
the &lt;sequence&gt; indicator. This means that the child elements must appear in the same order 
as they are declared. You will learn more about indicators in the XSD Indicators chapter.</p>
<p>2. The "employee" element can have a type attribute that refers to the name of the complex 
type to use:</p>
<code><pre>
&lt;xs:element name="employee" type="personinfor"/&gt;

&lt;xs:complexType name="personinfo"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="firstname" type="xs:string"/&gt;
        &lt;xs:element name="lastname" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;
</pre></code>
<p>If you use the method described above, several elements can refer to the same complex type,
like this:</p>
<code><pre>
&lt;xs:element name="employee" type="personinfo"/&gt;
&lt;xs:element name="student" type="personinfo"/&gt;
&lt;xs:element name="member" type="personinfo"/&gt;

&lt;xs:complexType name="personinfo"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="firstname" type="xs:string"/&gt;
        &lt;xs:element name="lastname" type="xs:string/&gt;
    &lt;/xs:sequenc&gt;
&lt;/xs:complexType&gt;
</pre></code>
<p>You can also base a complex element on an existing complex element and add some elements,
like this:</p>
<code><pre>
&lt;xs:element name="employee" type="fullpersoninfo"/&gt;

&lt;xs:complexType name="personinfo"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="firstname" type="xs:string"/&gt;
        &lt;xs:element name="lastname" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

&lt;xs:complexType name="fullpersoninfo"&gt;
    &lt;xs:complexContent&gt;
        &lt;xs:extension base="personinfo"&gt;
            &lt;xs:sequence&gt;
                &lt;xs:element name="address" type="xs:string"/&gt;
                &lt;xs:element name="city" type="xs:string"/&gt;
                &lt;xs:element name="country" type="xs:string"/&gt;
            &lt;/xs:sequence&gt;
        &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
&lt;/xs:complexType&gt;
</pre></code>
<hr/>


<h1>XSD Empty Elements</h1>
<p>An empty complex element cannot have contents, only attributes.</p>
<h2>Complex Empty Elemetns</h2>
<p>An empty XML element:</p>
<code><pre>
&lt;product prodid="12345"/&gt;
</pre></code>
<p>The "product" element above has no content at all. To define a type with no content, 
we must define a type that allows elements in its content, but we do not actually declare 
any elements, like this:</p>
<code><pre>
&lt;xs:element name="produce"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:complexContent&gt;
            &lt;xs:restriction base="xs:integer"&gt;
                &lt;xs:attribute name="prodid" type="xs:positiveInteger"/&gt;
            &lt;/xs:restriction&gt;
        &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></code>
<p>In the example above, we define a complex type with a complex content. The complexContent 
element signals that we intend to restrict or extend the content model of a complex type, 
and the restriction of integer declares one attribute but does not introduce any element content.</p>
<p>However, it is possible to declare the "product" element more compactly, like this:</p>
<code><pre>
&lt;xs:element name="product"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:attribute name="prodid" type="xs:positiveInteger"/&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></code>
<p>Or you can give the complexType element a name, and let the "product" element have a type 
attribute that refers to the name of the complexType (if you use this method, several elements 
can refer to the same complex type):</p>
<code><pre>
&lt;xs:element name="product" type="prodtype"/&gt;

&lt;xs:complexType name="prodtype"&gt;
    &lt;xs:attribute name="prodid" type="xs:positiveInteger"/&gt;
&lt;/xs:complexType&gt;
</pre></code>
<hr/>

<h1>XSD Elements Only</h1>
<p>An "elements-only" complex type contains an element that contains only other elements.</p>
<h2>Complex Types Containing Elements Only</h2>
<p>An XML element, "person", that contains only other elements:</p>
<code><pre>
&lt;person&gt;
    &lt;firstname&gt;John&lt;/fristname&gt;
    &lt;lastname&gt;Smith&lt;/lastname&gt;
&lt;/person&gt;
</pre></code>
<p>You can define the "person" element in a schema, like this:</p>
<code><pre>
&lt;xs:element name="person"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:element name="firstname" type="xs:string:"/&gt;
        &lt;xs:element name="lastname" type="xs:string:"/&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></code>
<p>Notice the &lt;xs:sequence&gt; tag. It means that the elements defined ("firstname" and 
"lastname") must appear in that order inside a "person" element.</p>
<p>Or you can give the complexType element a name, and let the "person" element have a type 
attribute that refers to the name of the complexType (if you use this method, several 
elements can refer to the same complex type):</p>
</pre></code>
<p>You can define the "person" element in a schema, like this:</p>
<code><pre>
&lt;element name="person" type="persontype"/&gt;

&lt;xs:complexType name="persontype"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="firstname" type="xs:string"/&gt;
        &lt;xs:element name="firstname" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;
</pre></code>
<hr/>

<h1>XSD Text-Only Elements</h1>
<p>A complex text-only element can contain text and attributes.</p>
<h2>Complex Text-Only Elements</h2>
<p>This type contains only simple content (text and attributes), therefore we add a 
simpleContent element around the content. When using simple content, you must define 
an extension OR a restriction within the simpleContent element, like this:</p>
<code><pre>
&lt;xs:element name="somename"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:simpleContent&gt;
            &lt;xs:extension base="basetype"&gt;
                ....
                ....
            &lt;/xs:extension&gt;
        &lt;/xssimpleContent&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

OR

&lt;xs:element name="somename"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:simpleContent&gt;
            &lt;xs:restriction base="basetype"&gt;
                ....
                ....
            &lt;/xs:restriction&gt;
        &lt;/xssimpleContent&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></code>
<p><b>Tip</b>: Uset the extension/restriction element to expand or limit the base simple 
type for the element.</p>
<p>Here is an example of an XML element, "shoesize", that contains text-only:</p>
<code><pre>
&lt;xs:element name="shoesize&gt;
    &lt;xs:complexType&gt;
        &lt;xs:simpleContent&gt;
            &lt;xs:restriction base="xs:integer"&gt;
                &lt;xs:attribute name="country" type="xs:string" /&gt;
            &lt;/xs:restriction&gt;
        &lt;/xssimpleContent&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></code>
<p>We could also give the complexType element a name, and let the "shoesize" element 
have a type attribute that refers to the name of the complexType (if you use this 
method, several elements can refer to the same complex type):</p>
<code><pre>
&lt;xs:element name="shoesize" type="shoetype"/&gt;

&lt;xs:complexType name="shoetype"&gt;
    &lt;xs:simpleContent&gt;
        &lt;xs:extension base="xs:integer"&gt;
            &lt;xs:attribute name="country" type="xs:string" /&gt;
        &lt;/xs:extension&gt;
    &lt;/xs:simpleContent&gt;
&lt;/xs:complexType&gt;
</pre></code>
<hr/>

<h1>XSD Mixed Content</h1>
<p>A mixed complex type element can contain attributes, elements, and text.</p>
<h2>Complex Types with Mixed Content</h2>
<p>An XML element, "letter", that contains both text and other elements:</p>
<code><pre>
&lt;letter&gt;
    Dear Mr.&lt;name&gt;JohnSmith&lt;/&gt;.
    Your order &lt;orderid&gt;1032&lt;/&gt;
    will be shipped on &lt;shipdate&gt;2001-07-13&lt;/shipdate&gt;.
&lt;/letter&gt;
</pre></code>
<p>The following schema declares the "letter" element:</p>
<code><pre>
&lt;xs:element name="letter"&gt;
    &lt;xs:complexType mixed="true"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element name="name" type="xs:string"/&gt;
            &lt;xs:element name="orderid" type="xs:positiveInteger"/&gt;
            &lt;xs:element name="shipdate" type="xs:date"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></code>
<p><b>Note</b>: To enable character data to appear between the child-elements of "letter", 
the mixed attribute must be set to "true". The &lt;xs:sequence&gt; tag means that the 
elements defined (name, orderid and shipdate) must appear in that order inside a "letter" element.</p>
<p>We could also give the complexType element a name, and let the "letter" element have a 
type attribute that refers to the name of the complexType (if you use this method, several 
elements can refer to the same complex type):</p>
<code><pre>
&lt;xs:element name="letter" type="lettertype"/&gt;

&lt;xs:complexType name="lettertype" mixed="true"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="name" type="xs:string"/&gt;
        &lt;xs:element name="orderid" type="xs:positiveInteger"/&gt;
        &lt;xs:element name="shipdate" type="xs:date"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;
</pre></code>
<hr/>

<h1>XSD Indicators</h1>
<p>We can control How elements are to be used in documents with indicators.</p>
<h2>Indicators</h2>
<p>There are seven indicators:</p>
<p>Order indicators:</p>
<ul>
<li>All</li>
<li>Choice</li>
<li>Sequence</li>
</ul>
<p>Occurrence indicators:</p>
<ul>
<li>maxOccurs</li>
<li>minOccurs</li>
</ul>
<p>Group indicators:</p>
<ul>
<li>Group name</li>
<li>attributeGroup name</li>
</ul>
<h2>Order Indicators</h2>
<p>Order indicators are used to define the order of the elements.</p>
<h3>ALl Indicator</h3>
<p>The &lt;all&gt; indicator specifies that the child elements can appear in any order, and 
that each child element must occur only once:</p>
<code><pre>
&lt;xs:element name="person"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:all&gt;
            &lt;xs:element name="firstname" type="xs:string"/&gt;
            &lt;xs:element name="lastname" type="xs:string"/&gt;
        &lt;/xs:all&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></code>
<p><b>Note</b>: When using the&lt;all&gt; indicator you can set the &lt;minOccurs&gt; indicator 
to 0 or 1 and the &lt;maxOccurs&gt; indicator can only be set to 1 (the &lt;minOccurs&gt; and 
&lt;maxOccurs&gt; are described later).</p>
<h2>Choice Indicator</h2>
<p>The &lt;choice&gt; indicator specifies that either one child element or another can occur:</p>
<code><pre>
&lt;xs:element name="person"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:choice&gt;
            &lt;element name="employee" type="employee"/&gt;
            &lt;element name="member" type="member"/&gt;
        &lt;/xs:choice&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></code>
<h2>Sequence Indicator</h2>
<p>The &lt;sequence&gt; indicator specifies that the child elements must appear in a 
specific order:</p>
<code><pre>
&lt;xs:element name="person"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:choice&gt;
            &lt;element name="employee" type="employee"/&gt;
            &lt;element name="member" type="member"/&gt;
        &lt;/xs:choice&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></code>
<h2>Occurrence Indicators</h2>
<p>Occurrence indicators are used to define how often an element can occur.</p>
<p><b>Note</b>: For all "Order" and "Group" indicators (any, all, choice, sequence, group name, 
and group reference) the default value for maxOccurs and minOccurs is 1.</p>
<h3>maxOccurs Indicator</h3>
<p>The &lt;maxOccurs&gt; indicator specifies the maximum number of times an element can occur:</p>
<code><pre>
&lt;xs:element name="person"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:choice&gt;
            &lt;element name="full_name" type="xs:string"/&gt;
            &lt;element name="child_name" type="xs:string" maxOccurs="10"/&gt;
        &lt;/xs:choice&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></code>
<p>The example above indicates that the "child_name" element can occur a minimum of one 
time (the default value for minOccurs is 1) and a maximum of ten times in the "person" element.</p>
<h3>minOccurs Indicator</h3>
<p>The &lt;minOccurs&gt; indicator specifies the minimum number of times an element can occur:</p>
<code><pre>
&lt;xs:element name="person"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element name="full_name" type="xs:string"/&gt;
            &lt;xs:element name="child_name" type="xs:string" maxOccurs="10" minOccurs="0"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></code>
<p>The example above indicates that the "child_name" element can occur a minimum of zero 
times and a maximum of ten times in the "person" element.</p>
<p><b>Tip</b>: To allow an element to appear an unlimited number of times, use the 
maxOccurs="unbounded" statement:</p>
<p><b>A working example:</b></p>
<p>An XML file called "Myfamily.xml":</p>
<a href="Myfamily.xml">Example</a>
<p>The XML file above contains a root element named "persons". Inside this root element we have 
defined three "person" elements. Each "person" element must contain a "full_name" element and 
it can contain up to five "child_name" elements.</p>
<hr/>

<h2>Group Indicators</h2>
<p>Group indicators are used to define related sets of elements.</p>
<h3>Element Groups</h3>
<p>Element groups are defined with the group declaration, like this:</p>
<code><pre>
&lt;xs:group name="groupname"&gt;
...
&lt;/xs:group&gt;
</pre></code>
<p>You must define an all, choice, or sequence element inside the group declaration.  The 
following example defines a group named "persongroup", that defines a group of elements 
that must occur in an exact sequence:</p>
<code><pre>
&lt;xs:group name="persongroup"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="firstname" type="xs:string"/&gt;
        &lt;xs:element name="lastname" type="xs:string"/&gt;
        &lt;xs:element name="birthday" type="xs:date"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:group&gt;
</pre></code>
<p>After you have defined a group, you can reference it in another definition, like this:</p>
<code><pre>
&lt;xs:group name="persongroup"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="firstname" type="xs:string"/&gt;
        &lt;xs:element name="lastname" type="xs:string"/&gt;
        &lt;xs:element name="birthday" type="xs:date"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:group&gt;

&lt;xs:element name="person" type="personinfo"/&gt;

&lt;xs:complexType name="personinfo"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:group ref="persongroup"/&gt;
        &lt;xs:element name="country" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;
</pre></code>
<h3>Attribute Groups</h3>
<p>Attribute groups are defined with the attributeGroup declaration, like this:</p>
<code><pre>
&lt;xs:attributeGroup name="groupname"&gt;
...
&lt;/xs:attributeGroup&gt;
</pre></code>
<p>The following example defines an attribute group named "personattrgroup":</p>
<code><pre>
&lt;xs:attributeGroup name="personattrgroup"&gt;
    &lt;xs:attribute name="firstname" type="xs:string"/&gt;
    &lt;xs:attribute name="lastname" type="xs:string"/&gt;
    &lt;xs:attribute name="birthday" type="xs:date"/&gt;
&lt;/xs:attributeGroup&gt;
</pre></code>
<p>After you have defined an attribute group, you can reference it in another 
definition, like this:</p>
<code><pre>
&lt;xs:attributeGroup name="personattrgroup"&gt;
    &lt;xs:attribute name="firstname" type="xs:string"/&gt;
    &lt;xs:attribute name="lastname" type="xs:string"/&gt;
    &lt;xs:attribute name="birthday" type="xs:date"/&gt;
&lt;/xs:attributeGroup&gt;

&lt;xs:element name="person"&gt;
    &lt;xs:complexType&gt;
        &lt;attributeGroup ref="personattrgroup"/&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></code>
<hr/>

<h1>XSD The &lt;any&gt; Element</h1>
<p>The &lt;any&gt; element enables us to extend the XML document with elements not specified 
by the schema!</p>
<h2>The &lt;andy&gt; Element</h2>
<p>The &lt;any&gt; element enables us to extend the XML document with elements not specified 
by the schema.</p>
<p>The following example is a fragment from an XML schema called "family.xsd". It shows a 
declaration for the "person" element. By using the &lt;any&gt; element we can extend 
(after &lt;lastname&gt;) the content of "person" with any element:</p>
<code><pre>
&lt;xs:element name="person"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element name="firstname" type="xs:string"/&gt;
            &lt;xs:element name="lastname" type="xs:string"/&gt;
            &lt;xs:any minOccurs="0"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></code>
<p>Now we want to extend the "person" element with a "children" element. In this case we can 
do so, even if the author of the schema above never declared any "children" element.</p>
<a href="Any_example.xsd">Example</a>
<p>The XML file above is valid because the schema "family.xsd" allows us to extend the "person" 
element with an optional element after the "lastname" element.</p>
<p>The &lt;any&gt; and &lt;anyAttribute&gt; elements are used to make EXTENSIBLE documents! They 
allow documents to contain additional elements that are not declared in the main XML schema.</p>
<hr/>

<h1>XSD The &lt;anyAttribute&gt; Element</h1>
<p>The &lt;anyAttribute&gt; element enables us to extend the XML document with attributes not 
specified by the schema!</p>
<h2>The &lt;andyAttribute&gt; Element</h2>
<p>The &lt;anyAttribute&gt; element enables us to extend the XML document with attributes not 
specified by the schema.</p>
<p>The following example is a fragment from an XML schema called "family.xsd". It shows a 
declaration for the "person" element. By using the &lt;anyAttribute&gt; element we can add any 
number of attributes to the "person" element:</p>
<code><pre>
&lt;xs:element name="person"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element name="firstname" type="xs:string"/&gt;
            &lt;xs:element name="lastname" type="xs:string"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:anyAttribute/&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></code>
<p>Now we want to extend the "person" element with a "gender" attribute. In this case we can 
do so, even if the author of the schema above never declared any "gender" attribute</p>
<a href="any_attribute.xml">Example</a>
<p>The XML file above is valid because the schema "family.xsd" allows us to add an attribute 
to the "person" element.</p>
<p>The &lt;any&gt; and &lt;anyAttribute&gt; elements are used to make EXTENSIBLE documents! 
They allow documents to contain additional elements that are not declared in the main XML schema.</p>
<hr/>

<h1>XSD Element Substitution</h1>
<p>With XML Schemas, one element can substitue another element.</p>
<h2>Element Substitution</h2>
<p>Let's say that we have users from two different countries: England and Norway. We would like the 
ability to let the user choose whether he or she would like to use the Norwegian element names or the
English element names in the XML document.</p>
<p>To solve this problem, we could define a <b>substitutionGroup</b> in the XML schema. First, 
we declare a head element and then we declare the other elements which state that they are 
substitutable for the head element</p>
<code><pre>
&lt;xs:element name="name" type="xs:string"/&gt;
&lt;xs:element name="navn" substitutionGroup="name"/&gt;
</pre></code>
<p>In the example above, the "name" element is the head element and the "navn" element is 
substitutable for "name".</p>
<p>Look at this fragment of an XML schema:</p>
<code><pre>
&lt;xs:element name="name" type="xs:string"/&gt;
&lt;xs:element name="navn" substitutionGroup="name"/&gt;

&lt;xs:complexType name="custinfo"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element ref="name"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

&lt;xs:element name="customer" type="custinfo"/&gt;
&lt;xs:element name="kunde" substitutionGroup="customer"/&gt;
</pre></code>
<p>A valid XML document (according to the schema above) could look like this:</p>
<code><pre>
&lt;customer&gt;
    &lt;name&gt;John Smith&lt;/name&gt;
&lt;/custorm&gt;
</pre></code>
<p>or like this:</p>
<code><pre>
&lt;kunde&gt;
    &lt;navn&gt;John Smith&lt;/navn&gt;
&lt;/kunde&gt;
</pre></code>
<h2>Blocking Element Substitution</h2>
<p>To prevent other elements from substituting with a specified element, use the block attribute:</p>
<code><pre>
&lt;xs:element name="name" type="xs:string" block="substitution"/&gt;
</pre></code>
<p>Look at this fragment of an XML schema:</p>
<code><pre>
&lt;xs:element name="name" type="xs:string" block="substitution"/&gt;
&lt;xs:element name="navn" substitutionGroup="name"/&gt;

&lt;xs:complexType name="custinfo"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element ref="name"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;
</pre></code>
<p>A valid XML document (according to the schema above) looks like this:</p>
<code><pre>
&lt;customer&gt;
    &lt;name&gt;John Smith&lt;/name&gt;
&lt;/customer&gt;
</pre></code>
<p>BUT THIS IS NO LONGER VALID:</p>
<code><pre>
&lt;kunde&gt;
    &lt;navn&gt;John Smith&lt;/navn&gt;
&lt;/kunde&gt;
</pre></code>
<h2>Using substitutionGroup</h2>
<p>The type of the substitutable elements must be the same as, or derived from, the type of the 
head element. If the type of the substitutable element is the same as the type of the head 
element you will not have to specify the type of the substitutable element.</p>
<h2>What are Global Elements?</h2>
<p>Global elements are elements that are immediate children of the "schema" element! Local elements 
are elements nested within other elements.</p>
</body>
</html>
